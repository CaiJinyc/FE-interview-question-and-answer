# 算法排序
参考：https://juejin.im/post/57dcd394a22b9d00610c5ec8#heading-15

## 1.冒泡排序
最好：n  最坏：n2 平均：n2

**思路：**  
1. 比较相邻的元素，如果第一个比第二个大，那就交换。
2. 从开始第一对到结尾最后一对，这样最后的一个就是最大数。
3. 重复 1,2 除了最后一个。

**实现：**  
```js
function bubbleSort (arr) {
 let len = arr.length, temp = null
 for (let i = 0; i < len; i++) {
   for (let j = 0; j < len - 1 - i; j++) {
     if (arr[j] > arr[j + 1]) {
       temp = arr[j]
       arr[j] = arr[j + 1]
       arr[j + 1] = temp
     }
   }
 }
 return arr
}
```

**改进：**  
```js
function bubbleSort (arr) {
  let i = arr.length - 1, temp = null, pos = 0
  while (i > 0) {
    pos = 0
    for (let j = 0; j < i; j++) {
      if (arr[j] > arr[j + 1]) {
        pos = j
        temp = arr[j]
        arr[j] = arr[j + 1]
        arr[j + 1] = temp
      }
    }
    i = pos
  }
  return arr
}
```

## 选择排序
最好：n2  最坏：n2 平均：n2

**思路：**  
每次循环都去找最小的那个值，然后交换位置。

```js
function selectionSort (arr) {
  let len = arr.length, temp = null, minIndex = null
  for (let i = 0; i < len - 1; i++) {
    minIndex = i
    for (let j = i + 1; j < len; j++) {
      if (arr[j] < arr[minIndex]) {
        minIndex = j 
      }
    }
    temp = arr[i]
    arr[i] = arr[minIndex]
    arr[minIndex] = temp
  }
  return arr
}
```

## 插入排序
最好：n  最坏：n2 平均：n2

**思路：**  

```js
function insertionSort (arr) {
  let len = arr.length, key = null
  for (let i = 1; i < len; i++) {
    key = arr[i]
    let j = i - 1
    while (j >= 0 && arr[j] > key) {
      arr[j + 1] = arr[j]
      j--
    }
    arr[j + 1] = key
  }
  return arr
}
```


## 归并排序
最好：n log n  最坏：n log n 平均：n log n

思路：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。

```js
function mergeSort (arr) {
  let len = arr.length
  if (len < 2) {
    return arr
  }
  let middle = Math.floor(len / 2),
      left = arr.slice(0, middle),
      right = arr.slice(middle)
  return merge(mergeSort(left), mergeSort(right))
}

function merge (left, right) {
  let result = []
  while (left.length && right.length) {
    if (left[0] <= right[0]) {
      retult.push(left.shift())
    } else {
      result.push(right.shift())
    }
  }
  while (left.length) {
    result.push(left.shift())
  }
  while (right.length) {
    result.push(right.shift())
  }
  return result
}
```

# 快速排序
最好：n log n  最坏：n2 平均：n log n

参考：https://segmentfault.com/a/1190000009426421

思路：
- 先从序列中取出一个基准
- 比基准大的放基准左边，比基准小的放基准右边
- 然后左边后右边重复前两个操作，直到只有一个值

```js
function quickSort (arr) {
  arr = arr.slice(0)
  if (arr.length < 2) {return arr}
  let pIndex = Math.floor(arr.length / 2)
  let p = arr.splice(pIndex, 1)[0]
  let left = [], right = []
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > p) {
      right.push(arr[i])
    } else {
      left.push(arr[i])
    }
  }
  return quickSort(left).concat([p], quickSort(right))
}
```

# Array.sort 用什么排序
Chrome小于22个字符用插入，大于22个字符用快排。